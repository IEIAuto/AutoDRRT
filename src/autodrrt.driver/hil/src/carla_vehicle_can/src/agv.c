/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.0 Thu Apr 11 11:10:22 2024.
 */

#include <string.h>

#include "agv.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

int agv_throttle_command_pack(
    uint8_t *dst_p,
    const struct agv_throttle_command_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->throttle_pedal_en_ctrl, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->throttle_pedal_cmd, 0u, 0xffu);

    return (2);
}

int agv_throttle_command_unpack(
    struct agv_throttle_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->throttle_pedal_en_ctrl = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->throttle_pedal_cmd = unpack_right_shift_u8(src_p[1], 0u, 0xffu);

    return (0);
}

int agv_throttle_command_init(struct agv_throttle_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_throttle_command_t));

    return 0;
}

uint8_t agv_throttle_command_throttle_pedal_en_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

double agv_throttle_command_throttle_pedal_en_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_throttle_command_throttle_pedal_en_ctrl_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_throttle_command_throttle_pedal_cmd_encode(double value)
{
    return (uint8_t)(value);
}

double agv_throttle_command_throttle_pedal_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_throttle_command_throttle_pedal_cmd_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int agv_brake_command_pack(
    uint8_t *dst_p,
    const struct agv_brake_command_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->brake_pedal_en_ctrl, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->brake_pedal_cmd, 0u, 0xffu);

    return (2);
}

int agv_brake_command_unpack(
    struct agv_brake_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->brake_pedal_en_ctrl = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->brake_pedal_cmd = unpack_right_shift_u8(src_p[1], 0u, 0xffu);

    return (0);
}

int agv_brake_command_init(struct agv_brake_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_brake_command_t));

    return 0;
}

uint8_t agv_brake_command_brake_pedal_en_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_command_brake_pedal_en_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_command_brake_pedal_en_ctrl_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_brake_command_brake_pedal_cmd_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_command_brake_pedal_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_command_brake_pedal_cmd_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int agv_steer_command_pack(
    uint8_t *dst_p,
    const struct agv_steer_command_t *src_p,
    size_t size)
{
    uint16_t steer_angle_cmd;

    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u8(src_p->steer_angle_en_ctrl, 0u, 0xffu);
    steer_angle_cmd = (uint16_t)src_p->steer_angle_cmd;
    dst_p[1] |= pack_left_shift_u16(steer_angle_cmd, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(steer_angle_cmd, 8u, 0xffu);

    return (3);
}

int agv_steer_command_unpack(
    struct agv_steer_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steer_angle_cmd;

    if (size < 3u) {
        return (-EINVAL);
    }

    dst_p->steer_angle_en_ctrl = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    steer_angle_cmd = unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    steer_angle_cmd |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->steer_angle_cmd = (int16_t)steer_angle_cmd;

    return (0);
}

int agv_steer_command_init(struct agv_steer_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_steer_command_t));

    return 0;
}

uint8_t agv_steer_command_steer_angle_en_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

double agv_steer_command_steer_angle_en_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_steer_command_steer_angle_en_ctrl_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t agv_steer_command_steer_angle_cmd_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double agv_steer_command_steer_angle_cmd_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool agv_steer_command_steer_angle_cmd_is_in_range(int16_t value)
{
    return ((value >= -524) && (value <= 524));
}

int agv_turnsignal_command_pack(
    uint8_t *dst_p,
    const struct agv_turnsignal_command_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->turn_signal_cmd, 0u, 0xffu);

    return (1);
}

int agv_turnsignal_command_unpack(
    struct agv_turnsignal_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->turn_signal_cmd = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int agv_turnsignal_command_init(struct agv_turnsignal_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_turnsignal_command_t));

    return 0;
}

uint8_t agv_turnsignal_command_turn_signal_cmd_encode(double value)
{
    return (uint8_t)(value);
}

double agv_turnsignal_command_turn_signal_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_turnsignal_command_turn_signal_cmd_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

int agv_gear_command_pack(
    uint8_t *dst_p,
    const struct agv_gear_command_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->gear_cmd, 0u, 0xffu);

    return (1);
}

int agv_gear_command_unpack(
    struct agv_gear_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->gear_cmd = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int agv_gear_command_init(struct agv_gear_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_gear_command_t));

    return 0;
}

uint8_t agv_gear_command_gear_cmd_encode(double value)
{
    return (uint8_t)(value);
}

double agv_gear_command_gear_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_gear_command_gear_cmd_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 4u));
}

int agv_control_command_pack(
    uint8_t *dst_p,
    const struct agv_control_command_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ctrl_cmd, 0u, 0xffu);

    return (1);
}

int agv_control_command_unpack(
    struct agv_control_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->ctrl_cmd = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int agv_control_command_init(struct agv_control_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_control_command_t));

    return 0;
}

uint8_t agv_control_command_ctrl_cmd_encode(double value)
{
    return (uint8_t)(value);
}

double agv_control_command_ctrl_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_control_command_ctrl_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int agv_throttle_status__pack(
    uint8_t *dst_p,
    const struct agv_throttle_status__t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->throttle_pedal_en_sts, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->throttle_pedal_sts, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->drive_motor_err, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->battery_bms_err, 0u, 0xffu);

    return (4);
}

int agv_throttle_status__unpack(
    struct agv_throttle_status__t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->throttle_pedal_en_sts = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->throttle_pedal_sts = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->drive_motor_err = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->battery_bms_err = unpack_right_shift_u8(src_p[3], 0u, 0xffu);

    return (0);
}

int agv_throttle_status__init(struct agv_throttle_status__t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_throttle_status__t));

    return 0;
}

uint8_t agv_throttle_status__throttle_pedal_en_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_throttle_status__throttle_pedal_en_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_throttle_status__throttle_pedal_en_sts_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

uint8_t agv_throttle_status__throttle_pedal_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_throttle_status__throttle_pedal_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_throttle_status__throttle_pedal_sts_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint8_t agv_throttle_status__drive_motor_err_encode(double value)
{
    return (uint8_t)(value);
}

double agv_throttle_status__drive_motor_err_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_throttle_status__drive_motor_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_throttle_status__battery_bms_err_encode(double value)
{
    return (uint8_t)(value);
}

double agv_throttle_status__battery_bms_err_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_throttle_status__battery_bms_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int agv_brake_status__pack(
    uint8_t *dst_p,
    const struct agv_brake_status__t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->brake_pedal_en_sts, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->brake_pedal_sts, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->brake_err, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->emergency_btn_env, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->front_bump_env, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->back_bump_env, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->overspd_env, 0u, 0xffu);

    return (7);
}

int agv_brake_status__unpack(
    struct agv_brake_status__t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->brake_pedal_en_sts = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->brake_pedal_sts = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->brake_err = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->emergency_btn_env = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->front_bump_env = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->back_bump_env = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->overspd_env = unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

int agv_brake_status__init(struct agv_brake_status__t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_brake_status__t));

    return 0;
}

uint8_t agv_brake_status__brake_pedal_en_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__brake_pedal_en_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__brake_pedal_en_sts_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

uint8_t agv_brake_status__brake_pedal_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__brake_pedal_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__brake_pedal_sts_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint8_t agv_brake_status__brake_err_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__brake_err_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__brake_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_brake_status__emergency_btn_env_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__emergency_btn_env_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__emergency_btn_env_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_brake_status__front_bump_env_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__front_bump_env_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__front_bump_env_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_brake_status__back_bump_env_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__back_bump_env_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__back_bump_env_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_brake_status__overspd_env_encode(double value)
{
    return (uint8_t)(value);
}

double agv_brake_status__overspd_env_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_brake_status__overspd_env_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int agv_steer_status__pack(
    uint8_t *dst_p,
    const struct agv_steer_status__t *src_p,
    size_t size)
{
    uint16_t steer_angle_sts;

    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->steer_angle_en_sts, 0u, 0xffu);
    steer_angle_sts = (uint16_t)src_p->steer_angle_sts;
    dst_p[1] |= pack_left_shift_u16(steer_angle_sts, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(steer_angle_sts, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->steer_err, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->sensor_err, 0u, 0xffu);

    return (5);
}

int agv_steer_status__unpack(
    struct agv_steer_status__t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steer_angle_sts;

    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->steer_angle_en_sts = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    steer_angle_sts = unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    steer_angle_sts |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->steer_angle_sts = (int16_t)steer_angle_sts;
    dst_p->steer_err = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->sensor_err = unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

int agv_steer_status__init(struct agv_steer_status__t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_steer_status__t));

    return 0;
}

uint8_t agv_steer_status__steer_angle_en_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_steer_status__steer_angle_en_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_steer_status__steer_angle_en_sts_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

int16_t agv_steer_status__steer_angle_sts_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double agv_steer_status__steer_angle_sts_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool agv_steer_status__steer_angle_sts_is_in_range(int16_t value)
{
    return ((value >= -524) && (value <= 524));
}

uint8_t agv_steer_status__steer_err_encode(double value)
{
    return (uint8_t)(value);
}

double agv_steer_status__steer_err_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_steer_status__steer_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_steer_status__sensor_err_encode(double value)
{
    return (uint8_t)(value);
}

double agv_steer_status__sensor_err_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_steer_status__sensor_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int agv_turnsignal_status__pack(
    uint8_t *dst_p,
    const struct agv_turnsignal_status__t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->turn_signal_sts, 0u, 0xffu);

    return (1);
}

int agv_turnsignal_status__unpack(
    struct agv_turnsignal_status__t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->turn_signal_sts = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int agv_turnsignal_status__init(struct agv_turnsignal_status__t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_turnsignal_status__t));

    return 0;
}

uint8_t agv_turnsignal_status__turn_signal_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_turnsignal_status__turn_signal_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_turnsignal_status__turn_signal_sts_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

int agv_gear_status_pack(
    uint8_t *dst_p,
    const struct agv_gear_status_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->gear_sts, 0u, 0xffu);

    return (1);
}

int agv_gear_status_unpack(
    struct agv_gear_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->gear_sts = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int agv_gear_status_init(struct agv_gear_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_gear_status_t));

    return 0;
}

uint8_t agv_gear_status_gear_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_gear_status_gear_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_gear_status_gear_sts_is_in_range(uint8_t value)
{
    return ((value >= 1u) && (value <= 4u));
}

int agv_ecu_status_1_pack(
    uint8_t *dst_p,
    const struct agv_ecu_status_1_t *src_p,
    size_t size)
{
    uint16_t acc_speed;
    uint16_t speed;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    speed = (uint16_t)src_p->speed;
    dst_p[0] |= pack_left_shift_u16(speed, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(speed, 8u, 0xffu);
    acc_speed = (uint16_t)src_p->acc_speed;
    dst_p[2] |= pack_left_shift_u16(acc_speed, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(acc_speed, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->ctrl_sts, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->chassis_sts, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->chassis_err, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->chassis_err, 8u, 0xffu);

    return (8);
}

int agv_ecu_status_1_unpack(
    struct agv_ecu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acc_speed;
    uint16_t speed;

    if (size < 8u) {
        return (-EINVAL);
    }

    speed = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    speed |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->speed = (int16_t)speed;
    acc_speed = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    acc_speed |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->acc_speed = (int16_t)acc_speed;
    dst_p->ctrl_sts = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->chassis_sts = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->chassis_err = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->chassis_err |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int agv_ecu_status_1_init(struct agv_ecu_status_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_ecu_status_1_t));

    return 0;
}

int16_t agv_ecu_status_1_speed_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double agv_ecu_status_1_speed_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool agv_ecu_status_1_speed_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t agv_ecu_status_1_acc_speed_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double agv_ecu_status_1_acc_speed_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool agv_ecu_status_1_acc_speed_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t agv_ecu_status_1_ctrl_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_ecu_status_1_ctrl_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_ecu_status_1_ctrl_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t agv_ecu_status_1_chassis_sts_encode(double value)
{
    return (uint8_t)(value);
}

double agv_ecu_status_1_chassis_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_ecu_status_1_chassis_sts_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t agv_ecu_status_1_chassis_err_encode(double value)
{
    return (uint16_t)(value);
}

double agv_ecu_status_1_chassis_err_decode(uint16_t value)
{
    return ((double)value);
}

bool agv_ecu_status_1_chassis_err_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int agv_ecu_status_2_pack(
    uint8_t *dst_p,
    const struct agv_ecu_status_2_t *src_p,
    size_t size)
{
    uint16_t battery_current;
    uint16_t battery_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->battery_soc, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->battery_capacity, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->battery_voltage, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->battery_voltage, 8u, 0xffu);
    battery_current = (uint16_t)src_p->battery_current;
    dst_p[4] |= pack_left_shift_u16(battery_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(battery_current, 8u, 0xffu);
    battery_temperature = (uint16_t)src_p->battery_temperature;
    dst_p[6] |= pack_left_shift_u16(battery_temperature, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(battery_temperature, 8u, 0xffu);

    return (8);
}

int agv_ecu_status_2_unpack(
    struct agv_ecu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t battery_current;
    uint16_t battery_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->battery_soc = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->battery_capacity = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->battery_voltage = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->battery_voltage |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    battery_current = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    battery_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->battery_current = (int16_t)battery_current;
    battery_temperature = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    battery_temperature |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->battery_temperature = (int16_t)battery_temperature;

    return (0);
}

int agv_ecu_status_2_init(struct agv_ecu_status_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_ecu_status_2_t));

    return 0;
}

uint8_t agv_ecu_status_2_battery_soc_encode(double value)
{
    return (uint8_t)(value);
}

double agv_ecu_status_2_battery_soc_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_ecu_status_2_battery_soc_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint8_t agv_ecu_status_2_battery_capacity_encode(double value)
{
    return (uint8_t)(value);
}

double agv_ecu_status_2_battery_capacity_decode(uint8_t value)
{
    return ((double)value);
}

bool agv_ecu_status_2_battery_capacity_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint16_t agv_ecu_status_2_battery_voltage_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double agv_ecu_status_2_battery_voltage_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool agv_ecu_status_2_battery_voltage_is_in_range(uint16_t value)
{
    return (value <= 800u);
}

int16_t agv_ecu_status_2_battery_current_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double agv_ecu_status_2_battery_current_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool agv_ecu_status_2_battery_current_is_in_range(int16_t value)
{
    return ((value >= -600) && (value <= 600));
}

int16_t agv_ecu_status_2_battery_temperature_encode(double value)
{
    return (int16_t)(value);
}

double agv_ecu_status_2_battery_temperature_decode(int16_t value)
{
    return ((double)value);
}

bool agv_ecu_status_2_battery_temperature_is_in_range(int16_t value)
{
    return ((value >= -40) && (value <= 110));
}

int agv_ecu_status_3_pack(
    uint8_t *dst_p,
    const struct agv_ecu_status_3_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->ultrasound_dist_1, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->ultrasound_dist_2, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->ultrasound_dist_3, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->ultrasound_dist_4, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->ultrasound_dist_5, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->ultrasound_dist_6, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->ultrasound_dist_7, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ultrasound_dist_8, 0u, 0xffu);

    return (8);
}

int agv_ecu_status_3_unpack(
    struct agv_ecu_status_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ultrasound_dist_1 = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ultrasound_dist_2 = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ultrasound_dist_3 = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->ultrasound_dist_4 = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->ultrasound_dist_5 = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->ultrasound_dist_6 = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->ultrasound_dist_7 = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->ultrasound_dist_8 = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int agv_ecu_status_3_init(struct agv_ecu_status_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_ecu_status_3_t));

    return 0;
}

uint8_t agv_ecu_status_3_ultrasound_dist_1_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_1_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_1_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_2_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_2_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_2_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_3_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_3_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_3_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_4_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_4_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_4_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_5_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_5_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_5_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_6_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_6_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_6_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_7_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_7_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_7_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_3_ultrasound_dist_8_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_3_ultrasound_dist_8_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_3_ultrasound_dist_8_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

int agv_ecu_status_4_pack(
    uint8_t *dst_p,
    const struct agv_ecu_status_4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->ultrasound_dist_09, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->ultrasound_dist_10, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->ultrasound_dist_11, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->ultrasound_dist_12, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->ultrasound_dist_13, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->ultrasound_dist_14, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->ultrasound_dist_15, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ultrasound_dist_16, 0u, 0xffu);

    return (8);
}

int agv_ecu_status_4_unpack(
    struct agv_ecu_status_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ultrasound_dist_09 = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ultrasound_dist_10 = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ultrasound_dist_11 = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->ultrasound_dist_12 = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->ultrasound_dist_13 = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->ultrasound_dist_14 = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->ultrasound_dist_15 = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->ultrasound_dist_16 = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int agv_ecu_status_4_init(struct agv_ecu_status_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_ecu_status_4_t));

    return 0;
}

uint8_t agv_ecu_status_4_ultrasound_dist_09_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_09_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_09_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_10_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_10_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_10_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_11_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_11_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_11_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_12_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_12_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_12_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_13_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_13_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_13_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_14_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_14_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_14_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_15_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_15_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_15_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

uint8_t agv_ecu_status_4_ultrasound_dist_16_encode(double value)
{
    return (uint8_t)(value / 2.0);
}

double agv_ecu_status_4_ultrasound_dist_16_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool agv_ecu_status_4_ultrasound_dist_16_is_in_range(uint8_t value)
{
    return (value <= 250u);
}

int agv_ecu_status_5_pack(
    uint8_t *dst_p,
    const struct agv_ecu_status_5_t *src_p,
    size_t size)
{
    uint16_t wheel_l_rotational_rate;
    uint16_t wheel_l_speed;
    uint16_t wheel_l_tick_rate;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->wheel_l_tick_count, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->wheel_l_tick_count, 8u, 0xffu);
    wheel_l_tick_rate = (uint16_t)src_p->wheel_l_tick_rate;
    dst_p[2] |= pack_left_shift_u16(wheel_l_tick_rate, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(wheel_l_tick_rate, 8u, 0xffu);
    wheel_l_rotational_rate = (uint16_t)src_p->wheel_l_rotational_rate;
    dst_p[4] |= pack_left_shift_u16(wheel_l_rotational_rate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(wheel_l_rotational_rate, 8u, 0xffu);
    wheel_l_speed = (uint16_t)src_p->wheel_l_speed;
    dst_p[6] |= pack_left_shift_u16(wheel_l_speed, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(wheel_l_speed, 8u, 0xffu);

    return (8);
}

int agv_ecu_status_5_unpack(
    struct agv_ecu_status_5_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t wheel_l_rotational_rate;
    uint16_t wheel_l_speed;
    uint16_t wheel_l_tick_rate;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->wheel_l_tick_count = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->wheel_l_tick_count |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    wheel_l_tick_rate = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    wheel_l_tick_rate |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->wheel_l_tick_rate = (int16_t)wheel_l_tick_rate;
    wheel_l_rotational_rate = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    wheel_l_rotational_rate |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->wheel_l_rotational_rate = (int16_t)wheel_l_rotational_rate;
    wheel_l_speed = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    wheel_l_speed |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->wheel_l_speed = (int16_t)wheel_l_speed;

    return (0);
}

int agv_ecu_status_5_init(struct agv_ecu_status_5_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_ecu_status_5_t));

    return 0;
}

uint16_t agv_ecu_status_5_wheel_l_tick_count_encode(double value)
{
    return (uint16_t)(value);
}

double agv_ecu_status_5_wheel_l_tick_count_decode(uint16_t value)
{
    return ((double)value);
}

bool agv_ecu_status_5_wheel_l_tick_count_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t agv_ecu_status_5_wheel_l_tick_rate_encode(double value)
{
    return (int16_t)(value);
}

double agv_ecu_status_5_wheel_l_tick_rate_decode(int16_t value)
{
    return ((double)value);
}

bool agv_ecu_status_5_wheel_l_tick_rate_is_in_range(int16_t value)
{
    return ((value >= -980) && (value <= 980));
}

int16_t agv_ecu_status_5_wheel_l_rotational_rate_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double agv_ecu_status_5_wheel_l_rotational_rate_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool agv_ecu_status_5_wheel_l_rotational_rate_is_in_range(int16_t value)
{
    return ((value >= -5130) && (value <= 5130));
}

int16_t agv_ecu_status_5_wheel_l_speed_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double agv_ecu_status_5_wheel_l_speed_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool agv_ecu_status_5_wheel_l_speed_is_in_range(int16_t value)
{
    return ((value >= -1111) && (value <= 1111));
}

int agv_ecu_status_6_pack(
    uint8_t *dst_p,
    const struct agv_ecu_status_6_t *src_p,
    size_t size)
{
    uint16_t wheel_r_rotational_rate;
    uint16_t wheel_r_speed;
    uint16_t wheel_r_tick_rate;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->wheel_r_tick_count, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->wheel_r_tick_count, 8u, 0xffu);
    wheel_r_tick_rate = (uint16_t)src_p->wheel_r_tick_rate;
    dst_p[2] |= pack_left_shift_u16(wheel_r_tick_rate, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(wheel_r_tick_rate, 8u, 0xffu);
    wheel_r_rotational_rate = (uint16_t)src_p->wheel_r_rotational_rate;
    dst_p[4] |= pack_left_shift_u16(wheel_r_rotational_rate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(wheel_r_rotational_rate, 8u, 0xffu);
    wheel_r_speed = (uint16_t)src_p->wheel_r_speed;
    dst_p[6] |= pack_left_shift_u16(wheel_r_speed, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(wheel_r_speed, 8u, 0xffu);

    return (8);
}

int agv_ecu_status_6_unpack(
    struct agv_ecu_status_6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t wheel_r_rotational_rate;
    uint16_t wheel_r_speed;
    uint16_t wheel_r_tick_rate;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->wheel_r_tick_count = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->wheel_r_tick_count |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    wheel_r_tick_rate = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    wheel_r_tick_rate |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->wheel_r_tick_rate = (int16_t)wheel_r_tick_rate;
    wheel_r_rotational_rate = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    wheel_r_rotational_rate |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->wheel_r_rotational_rate = (int16_t)wheel_r_rotational_rate;
    wheel_r_speed = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    wheel_r_speed |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->wheel_r_speed = (int16_t)wheel_r_speed;

    return (0);
}

int agv_ecu_status_6_init(struct agv_ecu_status_6_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct agv_ecu_status_6_t));

    return 0;
}

uint16_t agv_ecu_status_6_wheel_r_tick_count_encode(double value)
{
    return (uint16_t)(value);
}

double agv_ecu_status_6_wheel_r_tick_count_decode(uint16_t value)
{
    return ((double)value);
}

bool agv_ecu_status_6_wheel_r_tick_count_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t agv_ecu_status_6_wheel_r_tick_rate_encode(double value)
{
    return (int16_t)(value);
}

double agv_ecu_status_6_wheel_r_tick_rate_decode(int16_t value)
{
    return ((double)value);
}

bool agv_ecu_status_6_wheel_r_tick_rate_is_in_range(int16_t value)
{
    return ((value >= -980) && (value <= 980));
}

int16_t agv_ecu_status_6_wheel_r_rotational_rate_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double agv_ecu_status_6_wheel_r_rotational_rate_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool agv_ecu_status_6_wheel_r_rotational_rate_is_in_range(int16_t value)
{
    return ((value >= -5130) && (value <= 5130));
}

int16_t agv_ecu_status_6_wheel_r_speed_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double agv_ecu_status_6_wheel_r_speed_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool agv_ecu_status_6_wheel_r_speed_is_in_range(int16_t value)
{
    return ((value >= -1111) && (value <= 1111));
}
